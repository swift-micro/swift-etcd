//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: lock.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import SwiftProtobuf


/// The lock service exposes client-side locking facilities as a gRPC interface.
///
/// Usage: instantiate `V3lockpb_LockClient`, then call methods of this protocol to make API calls.
public protocol V3lockpb_LockClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: V3lockpb_LockClientInterceptorFactoryProtocol? { get }

  func lock(
    _ request: V3lockpb_LockRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<V3lockpb_LockRequest, V3lockpb_LockResponse>

  func unlock(
    _ request: V3lockpb_UnlockRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<V3lockpb_UnlockRequest, V3lockpb_UnlockResponse>
}

extension V3lockpb_LockClientProtocol {
  public var serviceName: String {
    return "v3lockpb.Lock"
  }

  /// Lock acquires a distributed shared lock on a given named lock.
  /// On success, it will return a unique key that exists so long as the
  /// lock is held by the caller. This key can be used in conjunction with
  /// transactions to safely ensure updates to etcd only occur while holding
  /// lock ownership. The lock is held until Unlock is called on the key or the
  /// lease associate with the owner expires.
  ///
  /// - Parameters:
  ///   - request: Request to send to Lock.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func lock(
    _ request: V3lockpb_LockRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<V3lockpb_LockRequest, V3lockpb_LockResponse> {
    return self.makeUnaryCall(
      path: "/v3lockpb.Lock/Lock",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLockInterceptors() ?? []
    )
  }

  /// Unlock takes a key returned by Lock and releases the hold on lock. The
  /// next Lock caller waiting for the lock will then be woken up and given
  /// ownership of the lock.
  ///
  /// - Parameters:
  ///   - request: Request to send to Unlock.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func unlock(
    _ request: V3lockpb_UnlockRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<V3lockpb_UnlockRequest, V3lockpb_UnlockResponse> {
    return self.makeUnaryCall(
      path: "/v3lockpb.Lock/Unlock",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUnlockInterceptors() ?? []
    )
  }
}

public protocol V3lockpb_LockClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'lock'.
  func makeLockInterceptors() -> [ClientInterceptor<V3lockpb_LockRequest, V3lockpb_LockResponse>]

  /// - Returns: Interceptors to use when invoking 'unlock'.
  func makeUnlockInterceptors() -> [ClientInterceptor<V3lockpb_UnlockRequest, V3lockpb_UnlockResponse>]
}

public final class V3lockpb_LockClient: V3lockpb_LockClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: V3lockpb_LockClientInterceptorFactoryProtocol?

  /// Creates a client for the v3lockpb.Lock service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: V3lockpb_LockClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The lock service exposes client-side locking facilities as a gRPC interface.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol V3lockpb_LockProvider: CallHandlerProvider {
  var interceptors: V3lockpb_LockServerInterceptorFactoryProtocol? { get }

  /// Lock acquires a distributed shared lock on a given named lock.
  /// On success, it will return a unique key that exists so long as the
  /// lock is held by the caller. This key can be used in conjunction with
  /// transactions to safely ensure updates to etcd only occur while holding
  /// lock ownership. The lock is held until Unlock is called on the key or the
  /// lease associate with the owner expires.
  func lock(request: V3lockpb_LockRequest, context: StatusOnlyCallContext) -> EventLoopFuture<V3lockpb_LockResponse>

  /// Unlock takes a key returned by Lock and releases the hold on lock. The
  /// next Lock caller waiting for the lock will then be woken up and given
  /// ownership of the lock.
  func unlock(request: V3lockpb_UnlockRequest, context: StatusOnlyCallContext) -> EventLoopFuture<V3lockpb_UnlockResponse>
}

extension V3lockpb_LockProvider {
  public var serviceName: Substring { return "v3lockpb.Lock" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "Lock":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<V3lockpb_LockRequest>(),
        responseSerializer: ProtobufSerializer<V3lockpb_LockResponse>(),
        interceptors: self.interceptors?.makeLockInterceptors() ?? [],
        userFunction: self.lock(request:context:)
      )

    case "Unlock":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<V3lockpb_UnlockRequest>(),
        responseSerializer: ProtobufSerializer<V3lockpb_UnlockResponse>(),
        interceptors: self.interceptors?.makeUnlockInterceptors() ?? [],
        userFunction: self.unlock(request:context:)
      )

    default:
      return nil
    }
  }
}

public protocol V3lockpb_LockServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'lock'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeLockInterceptors() -> [ServerInterceptor<V3lockpb_LockRequest, V3lockpb_LockResponse>]

  /// - Returns: Interceptors to use when handling 'unlock'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeUnlockInterceptors() -> [ServerInterceptor<V3lockpb_UnlockRequest, V3lockpb_UnlockResponse>]
}
