// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Etcdserverpb_AlarmType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// default, used to query if any alarm is active
  case none // = 0

  /// space quota is exhausted
  case nospace // = 1

  /// kv store corruption detected
  case corrupt // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .nospace
    case 2: self = .corrupt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .nospace: return 1
    case .corrupt: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Etcdserverpb_AlarmType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Etcdserverpb_AlarmType] = [
    .none,
    .nospace,
    .corrupt,
  ]
}

#endif  // swift(>=4.2)

public struct Etcdserverpb_ResponseHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cluster_id is the ID of the cluster which sent the response.
  public var clusterID: UInt64 = 0

  /// member_id is the ID of the member which sent the response.
  public var memberID: UInt64 = 0

  /// revision is the key-value store revision when the request was applied.
  public var revision: Int64 = 0

  /// raft_term is the raft term when the request was applied.
  public var raftTerm: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_RangeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key is the first key for the range. If range_end is not given, the request only looks up key.
  public var key: Data = Data()

  /// range_end is the upper bound on the requested range [key, range_end).
  /// If range_end is '\0', the range is all keys >= key.
  /// If range_end is key plus one (e.g., "aa"+1 == "ab", "a\xff"+1 == "b"),
  /// then the range request gets all keys prefixed with key.
  /// If both key and range_end are '\0', then the range request returns all keys.
  public var rangeEnd: Data = Data()

  /// limit is a limit on the number of keys returned for the request. When limit is set to 0,
  /// it is treated as no limit.
  public var limit: Int64 = 0

  /// revision is the point-in-time of the key-value store to use for the range.
  /// If revision is less or equal to zero, the range is over the newest key-value store.
  /// If the revision has been compacted, ErrCompacted is returned as a response.
  public var revision: Int64 = 0

  /// sort_order is the order for returned sorted results.
  public var sortOrder: Etcdserverpb_RangeRequest.SortOrder = .none

  /// sort_target is the key-value field to use for sorting.
  public var sortTarget: Etcdserverpb_RangeRequest.SortTarget = .key

  /// serializable sets the range request to use serializable member-local reads.
  /// Range requests are linearizable by default; linearizable requests have higher
  /// latency and lower throughput than serializable requests but reflect the current
  /// consensus of the cluster. For better performance, in exchange for possible stale reads,
  /// a serializable range request is served locally without needing to reach consensus
  /// with other nodes in the cluster.
  public var serializable: Bool = false

  /// keys_only when set returns only the keys and not the values.
  public var keysOnly: Bool = false

  /// count_only when set returns only the count of the keys in the range.
  public var countOnly: Bool = false

  /// min_mod_revision is the lower bound for returned key mod revisions; all keys with
  /// lesser mod revisions will be filtered away.
  public var minModRevision: Int64 = 0

  /// max_mod_revision is the upper bound for returned key mod revisions; all keys with
  /// greater mod revisions will be filtered away.
  public var maxModRevision: Int64 = 0

  /// min_create_revision is the lower bound for returned key create revisions; all keys with
  /// lesser create trevisions will be filtered away.
  public var minCreateRevision: Int64 = 0

  /// max_create_revision is the upper bound for returned key create revisions; all keys with
  /// greater create revisions will be filtered away.
  public var maxCreateRevision: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SortOrder: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// default, no sorting
    case none // = 0

    /// lowest target value first
    case ascend // = 1

    /// highest target value first
    case descend // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .ascend
      case 2: self = .descend
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .ascend: return 1
      case .descend: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum SortTarget: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case key // = 0
    case version // = 1
    case create // = 2
    case mod // = 3
    case value // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .key
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .key
      case 1: self = .version
      case 2: self = .create
      case 3: self = .mod
      case 4: self = .value
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .key: return 0
      case .version: return 1
      case .create: return 2
      case .mod: return 3
      case .value: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Etcdserverpb_RangeRequest.SortOrder: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Etcdserverpb_RangeRequest.SortOrder] = [
    .none,
    .ascend,
    .descend,
  ]
}

extension Etcdserverpb_RangeRequest.SortTarget: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Etcdserverpb_RangeRequest.SortTarget] = [
    .key,
    .version,
    .create,
    .mod,
    .value,
  ]
}

#endif  // swift(>=4.2)

public struct Etcdserverpb_RangeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// kvs is the list of key-value pairs matched by the range request.
  /// kvs is empty when count is requested.
  public var kvs: [Mvccpb_KeyValue] = []

  /// more indicates if there are more keys to return in the requested range.
  public var more: Bool = false

  /// count is set to the number of keys within the range when requested.
  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_PutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key is the key, in bytes, to put into the key-value store.
  public var key: Data = Data()

  /// value is the value, in bytes, to associate with the key in the key-value store.
  public var value: Data = Data()

  /// lease is the lease ID to associate with the key in the key-value store. A lease
  /// value of 0 indicates no lease.
  public var lease: Int64 = 0

  /// If prev_kv is set, etcd gets the previous key-value pair before changing it.
  /// The previous key-value pair will be returned in the put response.
  public var prevKv: Bool = false

  /// If ignore_value is set, etcd updates the key using its current value.
  /// Returns an error if the key does not exist.
  public var ignoreValue: Bool = false

  /// If ignore_lease is set, etcd updates the key using its current lease.
  /// Returns an error if the key does not exist.
  public var ignoreLease: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_PutResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// if prev_kv is set in the request, the previous key-value pair will be returned.
  public var prevKv: Mvccpb_KeyValue {
    get {return _prevKv ?? Mvccpb_KeyValue()}
    set {_prevKv = newValue}
  }
  /// Returns true if `prevKv` has been explicitly set.
  public var hasPrevKv: Bool {return self._prevKv != nil}
  /// Clears the value of `prevKv`. Subsequent reads from it will return its default value.
  public mutating func clearPrevKv() {self._prevKv = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
  fileprivate var _prevKv: Mvccpb_KeyValue? = nil
}

public struct Etcdserverpb_DeleteRangeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key is the first key to delete in the range.
  public var key: Data = Data()

  /// range_end is the key following the last key to delete for the range [key, range_end).
  /// If range_end is not given, the range is defined to contain only the key argument.
  /// If range_end is one bit larger than the given key, then the range is all the keys
  /// with the prefix (the given key).
  /// If range_end is '\0', the range is all keys greater than or equal to the key argument.
  public var rangeEnd: Data = Data()

  /// If prev_kv is set, etcd gets the previous key-value pairs before deleting it.
  /// The previous key-value pairs will be returned in the delete response.
  public var prevKv: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_DeleteRangeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// deleted is the number of keys deleted by the delete range request.
  public var deleted: Int64 = 0

  /// if prev_kv is set in the request, the previous key-value pairs will be returned.
  public var prevKvs: [Mvccpb_KeyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_RequestOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// request is a union of request types accepted by a transaction.
  public var request: Etcdserverpb_RequestOp.OneOf_Request? = nil

  public var requestRange: Etcdserverpb_RangeRequest {
    get {
      if case .requestRange(let v)? = request {return v}
      return Etcdserverpb_RangeRequest()
    }
    set {request = .requestRange(newValue)}
  }

  public var requestPut: Etcdserverpb_PutRequest {
    get {
      if case .requestPut(let v)? = request {return v}
      return Etcdserverpb_PutRequest()
    }
    set {request = .requestPut(newValue)}
  }

  public var requestDeleteRange: Etcdserverpb_DeleteRangeRequest {
    get {
      if case .requestDeleteRange(let v)? = request {return v}
      return Etcdserverpb_DeleteRangeRequest()
    }
    set {request = .requestDeleteRange(newValue)}
  }

  public var requestTxn: Etcdserverpb_TxnRequest {
    get {
      if case .requestTxn(let v)? = request {return v}
      return Etcdserverpb_TxnRequest()
    }
    set {request = .requestTxn(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// request is a union of request types accepted by a transaction.
  public enum OneOf_Request: Equatable {
    case requestRange(Etcdserverpb_RangeRequest)
    case requestPut(Etcdserverpb_PutRequest)
    case requestDeleteRange(Etcdserverpb_DeleteRangeRequest)
    case requestTxn(Etcdserverpb_TxnRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Etcdserverpb_RequestOp.OneOf_Request, rhs: Etcdserverpb_RequestOp.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.requestRange, .requestRange): return {
        guard case .requestRange(let l) = lhs, case .requestRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestPut, .requestPut): return {
        guard case .requestPut(let l) = lhs, case .requestPut(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestDeleteRange, .requestDeleteRange): return {
        guard case .requestDeleteRange(let l) = lhs, case .requestDeleteRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestTxn, .requestTxn): return {
        guard case .requestTxn(let l) = lhs, case .requestTxn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Etcdserverpb_ResponseOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// response is a union of response types returned by a transaction.
  public var response: Etcdserverpb_ResponseOp.OneOf_Response? = nil

  public var responseRange: Etcdserverpb_RangeResponse {
    get {
      if case .responseRange(let v)? = response {return v}
      return Etcdserverpb_RangeResponse()
    }
    set {response = .responseRange(newValue)}
  }

  public var responsePut: Etcdserverpb_PutResponse {
    get {
      if case .responsePut(let v)? = response {return v}
      return Etcdserverpb_PutResponse()
    }
    set {response = .responsePut(newValue)}
  }

  public var responseDeleteRange: Etcdserverpb_DeleteRangeResponse {
    get {
      if case .responseDeleteRange(let v)? = response {return v}
      return Etcdserverpb_DeleteRangeResponse()
    }
    set {response = .responseDeleteRange(newValue)}
  }

  public var responseTxn: Etcdserverpb_TxnResponse {
    get {
      if case .responseTxn(let v)? = response {return v}
      return Etcdserverpb_TxnResponse()
    }
    set {response = .responseTxn(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// response is a union of response types returned by a transaction.
  public enum OneOf_Response: Equatable {
    case responseRange(Etcdserverpb_RangeResponse)
    case responsePut(Etcdserverpb_PutResponse)
    case responseDeleteRange(Etcdserverpb_DeleteRangeResponse)
    case responseTxn(Etcdserverpb_TxnResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Etcdserverpb_ResponseOp.OneOf_Response, rhs: Etcdserverpb_ResponseOp.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.responseRange, .responseRange): return {
        guard case .responseRange(let l) = lhs, case .responseRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.responsePut, .responsePut): return {
        guard case .responsePut(let l) = lhs, case .responsePut(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.responseDeleteRange, .responseDeleteRange): return {
        guard case .responseDeleteRange(let l) = lhs, case .responseDeleteRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.responseTxn, .responseTxn): return {
        guard case .responseTxn(let l) = lhs, case .responseTxn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Etcdserverpb_Compare {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// result is logical comparison operation for this comparison.
  public var result: Etcdserverpb_Compare.CompareResult = .equal

  /// target is the key-value field to inspect for the comparison.
  public var target: Etcdserverpb_Compare.CompareTarget = .version

  /// key is the subject key for the comparison operation.
  public var key: Data = Data()

  public var targetUnion: Etcdserverpb_Compare.OneOf_TargetUnion? = nil

  /// version is the version of the given key
  public var version: Int64 {
    get {
      if case .version(let v)? = targetUnion {return v}
      return 0
    }
    set {targetUnion = .version(newValue)}
  }

  /// create_revision is the creation revision of the given key
  public var createRevision: Int64 {
    get {
      if case .createRevision(let v)? = targetUnion {return v}
      return 0
    }
    set {targetUnion = .createRevision(newValue)}
  }

  /// mod_revision is the last modified revision of the given key.
  public var modRevision: Int64 {
    get {
      if case .modRevision(let v)? = targetUnion {return v}
      return 0
    }
    set {targetUnion = .modRevision(newValue)}
  }

  /// value is the value of the given key, in bytes.
  public var value: Data {
    get {
      if case .value(let v)? = targetUnion {return v}
      return Data()
    }
    set {targetUnion = .value(newValue)}
  }

  /// lease is the lease id of the given key.
  public var lease: Int64 {
    get {
      if case .lease(let v)? = targetUnion {return v}
      return 0
    }
    set {targetUnion = .lease(newValue)}
  }

  /// range_end compares the given target to all keys in the range [key, range_end).
  /// See RangeRequest for more details on key ranges.
  public var rangeEnd: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TargetUnion: Equatable {
    /// version is the version of the given key
    case version(Int64)
    /// create_revision is the creation revision of the given key
    case createRevision(Int64)
    /// mod_revision is the last modified revision of the given key.
    case modRevision(Int64)
    /// value is the value of the given key, in bytes.
    case value(Data)
    /// lease is the lease id of the given key.
    case lease(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Etcdserverpb_Compare.OneOf_TargetUnion, rhs: Etcdserverpb_Compare.OneOf_TargetUnion) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.version, .version): return {
        guard case .version(let l) = lhs, case .version(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createRevision, .createRevision): return {
        guard case .createRevision(let l) = lhs, case .createRevision(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.modRevision, .modRevision): return {
        guard case .modRevision(let l) = lhs, case .modRevision(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lease, .lease): return {
        guard case .lease(let l) = lhs, case .lease(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum CompareResult: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case equal // = 0
    case greater // = 1
    case less // = 2
    case notEqual // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .equal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .equal
      case 1: self = .greater
      case 2: self = .less
      case 3: self = .notEqual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .equal: return 0
      case .greater: return 1
      case .less: return 2
      case .notEqual: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum CompareTarget: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case version // = 0
    case create // = 1
    case mod // = 2
    case value // = 3
    case lease // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .version
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .version
      case 1: self = .create
      case 2: self = .mod
      case 3: self = .value
      case 4: self = .lease
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .version: return 0
      case .create: return 1
      case .mod: return 2
      case .value: return 3
      case .lease: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Etcdserverpb_Compare.CompareResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Etcdserverpb_Compare.CompareResult] = [
    .equal,
    .greater,
    .less,
    .notEqual,
  ]
}

extension Etcdserverpb_Compare.CompareTarget: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Etcdserverpb_Compare.CompareTarget] = [
    .version,
    .create,
    .mod,
    .value,
    .lease,
  ]
}

#endif  // swift(>=4.2)

/// From google paxosdb paper:
/// Our implementation hinges around a powerful primitive which we call MultiOp. All other database
/// operations except for iteration are implemented as a single call to MultiOp. A MultiOp is applied atomically
/// and consists of three components:
/// 1. A list of tests called guard. Each test in guard checks a single entry in the database. It may check
/// for the absence or presence of a value, or compare with a given value. Two different tests in the guard
/// may apply to the same or different entries in the database. All tests in the guard are applied and
/// MultiOp returns the results. If all tests are true, MultiOp executes t op (see item 2 below), otherwise
/// it executes f op (see item 3 below).
/// 2. A list of database operations called t op. Each operation in the list is either an insert, delete, or
/// lookup operation, and applies to a single database entry. Two different operations in the list may apply
/// to the same or different entries in the database. These operations are executed
/// if guard evaluates to
/// true.
/// 3. A list of database operations called f op. Like t op, but executed if guard evaluates to false.
public struct Etcdserverpb_TxnRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// compare is a list of predicates representing a conjunction of terms.
  /// If the comparisons succeed, then the success requests will be processed in order,
  /// and the response will contain their respective responses in order.
  /// If the comparisons fail, then the failure requests will be processed in order,
  /// and the response will contain their respective responses in order.
  public var compare: [Etcdserverpb_Compare] = []

  /// success is a list of requests which will be applied when compare evaluates to true.
  public var success: [Etcdserverpb_RequestOp] = []

  /// failure is a list of requests which will be applied when compare evaluates to false.
  public var failure: [Etcdserverpb_RequestOp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_TxnResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// succeeded is set to true if the compare evaluated to true or false otherwise.
  public var succeeded: Bool = false

  /// responses is a list of responses corresponding to the results from applying
  /// success if succeeded is true or failure if succeeded is false.
  public var responses: [Etcdserverpb_ResponseOp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

/// CompactionRequest compacts the key-value store up to a given revision. All superseded keys
/// with a revision less than the compaction revision will be removed.
public struct Etcdserverpb_CompactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// revision is the key-value store revision for the compaction operation.
  public var revision: Int64 = 0

  /// physical is set so the RPC will wait until the compaction is physically
  /// applied to the local database such that compacted entries are totally
  /// removed from the backend database.
  public var physical: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_CompactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_HashRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_HashKVRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// revision is the key-value store revision for the hash operation.
  public var revision: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_HashKVResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// hash is the hash value computed from the responding member's MVCC keys up to a given revision.
  public var hash: UInt32 = 0

  /// compact_revision is the compacted revision of key-value store when hash begins.
  public var compactRevision: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_HashResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// hash is the hash value computed from the responding member's KV's backend.
  public var hash: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_SnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_SnapshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header has the current key-value store information. The first header in the snapshot
  /// stream indicates the point in time of the snapshot.
  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// remaining_bytes is the number of blob bytes to be sent after this message
  public var remainingBytes: UInt64 = 0

  /// blob contains the next chunk of the snapshot in the snapshot stream.
  public var blob: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_WatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// request_union is a request to either create a new watcher or cancel an existing watcher.
  public var requestUnion: Etcdserverpb_WatchRequest.OneOf_RequestUnion? = nil

  public var createRequest: Etcdserverpb_WatchCreateRequest {
    get {
      if case .createRequest(let v)? = requestUnion {return v}
      return Etcdserverpb_WatchCreateRequest()
    }
    set {requestUnion = .createRequest(newValue)}
  }

  public var cancelRequest: Etcdserverpb_WatchCancelRequest {
    get {
      if case .cancelRequest(let v)? = requestUnion {return v}
      return Etcdserverpb_WatchCancelRequest()
    }
    set {requestUnion = .cancelRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// request_union is a request to either create a new watcher or cancel an existing watcher.
  public enum OneOf_RequestUnion: Equatable {
    case createRequest(Etcdserverpb_WatchCreateRequest)
    case cancelRequest(Etcdserverpb_WatchCancelRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Etcdserverpb_WatchRequest.OneOf_RequestUnion, rhs: Etcdserverpb_WatchRequest.OneOf_RequestUnion) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createRequest, .createRequest): return {
        guard case .createRequest(let l) = lhs, case .createRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cancelRequest, .cancelRequest): return {
        guard case .cancelRequest(let l) = lhs, case .cancelRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Etcdserverpb_WatchCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key is the key to register for watching.
  public var key: Data = Data()

  /// range_end is the end of the range [key, range_end) to watch. If range_end is not given,
  /// only the key argument is watched. If range_end is equal to '\0', all keys greater than
  /// or equal to the key argument are watched.
  /// If the range_end is one bit larger than the given key,
  /// then all keys with the prefix (the given key) will be watched.
  public var rangeEnd: Data = Data()

  /// start_revision is an optional revision to watch from (inclusive). No start_revision is "now".
  public var startRevision: Int64 = 0

  /// progress_notify is set so that the etcd server will periodically send a WatchResponse with
  /// no events to the new watcher if there are no recent events. It is useful when clients
  /// wish to recover a disconnected watcher starting from a recent known revision.
  /// The etcd server may decide how often it will send notifications based on current load.
  public var progressNotify: Bool = false

  /// filters filter the events at server side before it sends back to the watcher.
  public var filters: [Etcdserverpb_WatchCreateRequest.FilterType] = []

  /// If prev_kv is set, created watcher gets the previous KV before the event happens.
  /// If the previous KV is already compacted, nothing will be returned.
  public var prevKv: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FilterType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// filter out put event.
    case noput // = 0

    /// filter out delete event.
    case nodelete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .noput
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noput
      case 1: self = .nodelete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noput: return 0
      case .nodelete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Etcdserverpb_WatchCreateRequest.FilterType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Etcdserverpb_WatchCreateRequest.FilterType] = [
    .noput,
    .nodelete,
  ]
}

#endif  // swift(>=4.2)

public struct Etcdserverpb_WatchCancelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// watch_id is the watcher id to cancel so that no more events are transmitted.
  public var watchID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_WatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// watch_id is the ID of the watcher that corresponds to the response.
  public var watchID: Int64 = 0

  /// created is set to true if the response is for a create watch request.
  /// The client should record the watch_id and expect to receive events for
  /// the created watcher from the same stream.
  /// All events sent to the created watcher will attach with the same watch_id.
  public var created: Bool = false

  /// canceled is set to true if the response is for a cancel watch request.
  /// No further events will be sent to the canceled watcher.
  public var canceled: Bool = false

  /// compact_revision is set to the minimum index if a watcher tries to watch
  /// at a compacted index.
  ///
  /// This happens when creating a watcher at a compacted revision or the watcher cannot
  /// catch up with the progress of the key-value store.
  ///
  /// The client should treat the watcher as canceled and should not try to create any
  /// watcher with the same start_revision again.
  public var compactRevision: Int64 = 0

  /// cancel_reason indicates the reason for canceling the watcher.
  public var cancelReason: String = String()

  public var events: [Mvccpb_Event] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_LeaseGrantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TTL is the advisory time-to-live in seconds. Expired lease will return -1.
  public var ttl: Int64 = 0

  /// ID is the requested ID for the lease. If ID is set to 0, the lessor chooses an ID.
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_LeaseGrantResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// ID is the lease ID for the granted lease.
  public var id: Int64 = 0

  /// TTL is the server chosen lease time-to-live in seconds.
  public var ttl: Int64 = 0

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_LeaseRevokeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the lease ID to revoke. When the ID is revoked, all associated keys will be deleted.
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_LeaseRevokeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_LeaseKeepAliveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the lease ID for the lease to keep alive.
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_LeaseKeepAliveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// ID is the lease ID from the keep alive request.
  public var id: Int64 = 0

  /// TTL is the new time-to-live for the lease.
  public var ttl: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_LeaseTimeToLiveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the lease ID for the lease.
  public var id: Int64 = 0

  /// keys is true to query all the keys attached to this lease.
  public var keys: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_LeaseTimeToLiveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// ID is the lease ID from the keep alive request.
  public var id: Int64 = 0

  /// TTL is the remaining TTL in seconds for the lease; the lease will expire in under TTL+1 seconds.
  public var ttl: Int64 = 0

  /// GrantedTTL is the initial granted time in seconds upon lease creation/renewal.
  public var grantedTtl: Int64 = 0

  /// Keys is the list of keys attached to this lease.
  public var keys: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_LeaseLeasesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_LeaseStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: int64 TTL = 2;
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_LeaseLeasesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var leases: [Etcdserverpb_LeaseStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the member ID for this member.
  public var id: UInt64 = 0

  /// name is the human-readable name of the member. If the member is not started, the name will be an empty string.
  public var name: String = String()

  /// peerURLs is the list of URLs the member exposes to the cluster for communication.
  public var peerUrls: [String] = []

  /// clientURLs is the list of URLs the member exposes to clients for communication. If the member is not started, clientURLs will be empty.
  public var clientUrls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_MemberAddRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// peerURLs is the list of URLs the added member will use to communicate with the cluster.
  public var peerUrls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_MemberAddResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// member is the member information for the added member.
  public var member: Etcdserverpb_Member {
    get {return _member ?? Etcdserverpb_Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {self._member = nil}

  /// members is a list of all members after adding the new member.
  public var members: [Etcdserverpb_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
  fileprivate var _member: Etcdserverpb_Member? = nil
}

public struct Etcdserverpb_MemberRemoveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the member ID of the member to remove.
  public var id: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_MemberRemoveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// members is a list of all members after removing the member.
  public var members: [Etcdserverpb_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_MemberUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the member ID of the member to update.
  public var id: UInt64 = 0

  /// peerURLs is the new list of URLs the member will use to communicate with the cluster.
  public var peerUrls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_MemberUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// members is a list of all members after updating the member.
  public var members: [Etcdserverpb_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_MemberListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_MemberListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// members is a list of all members associated with the cluster.
  public var members: [Etcdserverpb_Member] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_DefragmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_DefragmentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_MoveLeaderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// targetID is the node ID for the new leader.
  public var targetID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_MoveLeaderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AlarmRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// action is the kind of alarm request to issue. The action
  /// may GET alarm statuses, ACTIVATE an alarm, or DEACTIVATE a
  /// raised alarm.
  public var action: Etcdserverpb_AlarmRequest.AlarmAction = .get

  /// memberID is the ID of the member associated with the alarm. If memberID is 0, the
  /// alarm request covers all members.
  public var memberID: UInt64 = 0

  /// alarm is the type of alarm to consider for this request.
  public var alarm: Etcdserverpb_AlarmType = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AlarmAction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case activate // = 1
    case deactivate // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .activate
      case 2: self = .deactivate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .activate: return 1
      case .deactivate: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Etcdserverpb_AlarmRequest.AlarmAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Etcdserverpb_AlarmRequest.AlarmAction] = [
    .get,
    .activate,
    .deactivate,
  ]
}

#endif  // swift(>=4.2)

public struct Etcdserverpb_AlarmMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// memberID is the ID of the member associated with the raised alarm.
  public var memberID: UInt64 = 0

  /// alarm is the type of alarm which has been raised.
  public var alarm: Etcdserverpb_AlarmType = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AlarmResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// alarms is a list of alarms associated with the alarm request.
  public var alarms: [Etcdserverpb_AlarmMember] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// version is the cluster protocol version used by the responding member.
  public var version: String = String()

  /// dbSize is the size of the backend database, in bytes, of the responding member.
  public var dbSize: Int64 = 0

  /// leader is the member ID which the responding member believes is the current leader.
  public var leader: UInt64 = 0

  /// raftIndex is the current raft index of the responding member.
  public var raftIndex: UInt64 = 0

  /// raftTerm is the current raft term of the responding member.
  public var raftTerm: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthEnableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthDisableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthenticateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthUserAddRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthUserGetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthUserDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the user to delete.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthUserChangePasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the user whose password is being changed.
  public var name: String = String()

  /// password is the new password for the user.
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthUserGrantRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user is the name of the user which should be granted a given role.
  public var user: String = String()

  /// role is the name of the role to grant to the user.
  public var role: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthUserRevokeRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var role: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthRoleAddRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the role to add to the authentication system.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthRoleGetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthUserListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthRoleListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthRoleDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthRoleGrantPermissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the role which will be granted the permission.
  public var name: String = String()

  /// perm is the permission to grant to the role.
  public var perm: Authpb_Permission {
    get {return _perm ?? Authpb_Permission()}
    set {_perm = newValue}
  }
  /// Returns true if `perm` has been explicitly set.
  public var hasPerm: Bool {return self._perm != nil}
  /// Clears the value of `perm`. Subsequent reads from it will return its default value.
  public mutating func clearPerm() {self._perm = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _perm: Authpb_Permission? = nil
}

public struct Etcdserverpb_AuthRoleRevokePermissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: String = String()

  public var key: String = String()

  public var rangeEnd: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Etcdserverpb_AuthEnableResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthDisableResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthenticateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// token is an authorized token that can be used in succeeding RPCs
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthUserAddResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthUserGetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var roles: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthUserDeleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthUserChangePasswordResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthUserGrantRoleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthUserRevokeRoleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthRoleAddResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthRoleGetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var perm: [Authpb_Permission] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthRoleListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var roles: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthUserListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var users: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthRoleDeleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthRoleGrantPermissionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

public struct Etcdserverpb_AuthRoleRevokePermissionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Etcdserverpb_ResponseHeader {
    get {return _header ?? Etcdserverpb_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Etcdserverpb_ResponseHeader? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "etcdserverpb"

extension Etcdserverpb_AlarmType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "NOSPACE"),
    2: .same(proto: "CORRUPT"),
  ]
}

extension Etcdserverpb_ResponseHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_id"),
    2: .standard(proto: "member_id"),
    3: .same(proto: "revision"),
    4: .standard(proto: "raft_term"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.clusterID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memberID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.revision) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.raftTerm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clusterID != 0 {
      try visitor.visitSingularUInt64Field(value: self.clusterID, fieldNumber: 1)
    }
    if self.memberID != 0 {
      try visitor.visitSingularUInt64Field(value: self.memberID, fieldNumber: 2)
    }
    if self.revision != 0 {
      try visitor.visitSingularInt64Field(value: self.revision, fieldNumber: 3)
    }
    if self.raftTerm != 0 {
      try visitor.visitSingularUInt64Field(value: self.raftTerm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_ResponseHeader, rhs: Etcdserverpb_ResponseHeader) -> Bool {
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.memberID != rhs.memberID {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.raftTerm != rhs.raftTerm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_RangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "range_end"),
    3: .same(proto: "limit"),
    4: .same(proto: "revision"),
    5: .standard(proto: "sort_order"),
    6: .standard(proto: "sort_target"),
    7: .same(proto: "serializable"),
    8: .standard(proto: "keys_only"),
    9: .standard(proto: "count_only"),
    10: .standard(proto: "min_mod_revision"),
    11: .standard(proto: "max_mod_revision"),
    12: .standard(proto: "min_create_revision"),
    13: .standard(proto: "max_create_revision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rangeEnd) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.revision) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.sortOrder) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.sortTarget) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.serializable) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.keysOnly) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.countOnly) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.minModRevision) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.maxModRevision) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.minCreateRevision) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.maxCreateRevision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.rangeEnd.isEmpty {
      try visitor.visitSingularBytesField(value: self.rangeEnd, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 3)
    }
    if self.revision != 0 {
      try visitor.visitSingularInt64Field(value: self.revision, fieldNumber: 4)
    }
    if self.sortOrder != .none {
      try visitor.visitSingularEnumField(value: self.sortOrder, fieldNumber: 5)
    }
    if self.sortTarget != .key {
      try visitor.visitSingularEnumField(value: self.sortTarget, fieldNumber: 6)
    }
    if self.serializable != false {
      try visitor.visitSingularBoolField(value: self.serializable, fieldNumber: 7)
    }
    if self.keysOnly != false {
      try visitor.visitSingularBoolField(value: self.keysOnly, fieldNumber: 8)
    }
    if self.countOnly != false {
      try visitor.visitSingularBoolField(value: self.countOnly, fieldNumber: 9)
    }
    if self.minModRevision != 0 {
      try visitor.visitSingularInt64Field(value: self.minModRevision, fieldNumber: 10)
    }
    if self.maxModRevision != 0 {
      try visitor.visitSingularInt64Field(value: self.maxModRevision, fieldNumber: 11)
    }
    if self.minCreateRevision != 0 {
      try visitor.visitSingularInt64Field(value: self.minCreateRevision, fieldNumber: 12)
    }
    if self.maxCreateRevision != 0 {
      try visitor.visitSingularInt64Field(value: self.maxCreateRevision, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_RangeRequest, rhs: Etcdserverpb_RangeRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.rangeEnd != rhs.rangeEnd {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.sortOrder != rhs.sortOrder {return false}
    if lhs.sortTarget != rhs.sortTarget {return false}
    if lhs.serializable != rhs.serializable {return false}
    if lhs.keysOnly != rhs.keysOnly {return false}
    if lhs.countOnly != rhs.countOnly {return false}
    if lhs.minModRevision != rhs.minModRevision {return false}
    if lhs.maxModRevision != rhs.maxModRevision {return false}
    if lhs.minCreateRevision != rhs.minCreateRevision {return false}
    if lhs.maxCreateRevision != rhs.maxCreateRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_RangeRequest.SortOrder: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "ASCEND"),
    2: .same(proto: "DESCEND"),
  ]
}

extension Etcdserverpb_RangeRequest.SortTarget: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY"),
    1: .same(proto: "VERSION"),
    2: .same(proto: "CREATE"),
    3: .same(proto: "MOD"),
    4: .same(proto: "VALUE"),
  ]
}

extension Etcdserverpb_RangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "kvs"),
    3: .same(proto: "more"),
    4: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.kvs) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.more) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.kvs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kvs, fieldNumber: 2)
    }
    if self.more != false {
      try visitor.visitSingularBoolField(value: self.more, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_RangeResponse, rhs: Etcdserverpb_RangeResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.kvs != rhs.kvs {return false}
    if lhs.more != rhs.more {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_PutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "lease"),
    4: .standard(proto: "prev_kv"),
    5: .standard(proto: "ignore_value"),
    6: .standard(proto: "ignore_lease"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lease) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.prevKv) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.ignoreValue) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ignoreLease) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if self.lease != 0 {
      try visitor.visitSingularInt64Field(value: self.lease, fieldNumber: 3)
    }
    if self.prevKv != false {
      try visitor.visitSingularBoolField(value: self.prevKv, fieldNumber: 4)
    }
    if self.ignoreValue != false {
      try visitor.visitSingularBoolField(value: self.ignoreValue, fieldNumber: 5)
    }
    if self.ignoreLease != false {
      try visitor.visitSingularBoolField(value: self.ignoreLease, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_PutRequest, rhs: Etcdserverpb_PutRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.lease != rhs.lease {return false}
    if lhs.prevKv != rhs.prevKv {return false}
    if lhs.ignoreValue != rhs.ignoreValue {return false}
    if lhs.ignoreLease != rhs.ignoreLease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_PutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "prev_kv"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._prevKv) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._prevKv {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_PutResponse, rhs: Etcdserverpb_PutResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._prevKv != rhs._prevKv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_DeleteRangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteRangeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "range_end"),
    3: .standard(proto: "prev_kv"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rangeEnd) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.prevKv) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.rangeEnd.isEmpty {
      try visitor.visitSingularBytesField(value: self.rangeEnd, fieldNumber: 2)
    }
    if self.prevKv != false {
      try visitor.visitSingularBoolField(value: self.prevKv, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_DeleteRangeRequest, rhs: Etcdserverpb_DeleteRangeRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.rangeEnd != rhs.rangeEnd {return false}
    if lhs.prevKv != rhs.prevKv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_DeleteRangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteRangeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "deleted"),
    3: .standard(proto: "prev_kvs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.deleted) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.prevKvs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.deleted != 0 {
      try visitor.visitSingularInt64Field(value: self.deleted, fieldNumber: 2)
    }
    if !self.prevKvs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prevKvs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_DeleteRangeResponse, rhs: Etcdserverpb_DeleteRangeResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs.prevKvs != rhs.prevKvs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_RequestOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestOp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_range"),
    2: .standard(proto: "request_put"),
    3: .standard(proto: "request_delete_range"),
    4: .standard(proto: "request_txn"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Etcdserverpb_RangeRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .requestRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .requestRange(v)
        }
      }()
      case 2: try {
        var v: Etcdserverpb_PutRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .requestPut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .requestPut(v)
        }
      }()
      case 3: try {
        var v: Etcdserverpb_DeleteRangeRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .requestDeleteRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .requestDeleteRange(v)
        }
      }()
      case 4: try {
        var v: Etcdserverpb_TxnRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .requestTxn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .requestTxn(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .requestRange?: try {
      guard case .requestRange(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .requestPut?: try {
      guard case .requestPut(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .requestDeleteRange?: try {
      guard case .requestDeleteRange(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .requestTxn?: try {
      guard case .requestTxn(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_RequestOp, rhs: Etcdserverpb_RequestOp) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_ResponseOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseOp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_range"),
    2: .standard(proto: "response_put"),
    3: .standard(proto: "response_delete_range"),
    4: .standard(proto: "response_txn"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Etcdserverpb_RangeResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .responseRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .responseRange(v)
        }
      }()
      case 2: try {
        var v: Etcdserverpb_PutResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .responsePut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .responsePut(v)
        }
      }()
      case 3: try {
        var v: Etcdserverpb_DeleteRangeResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .responseDeleteRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .responseDeleteRange(v)
        }
      }()
      case 4: try {
        var v: Etcdserverpb_TxnResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .responseTxn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .responseTxn(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.response {
    case .responseRange?: try {
      guard case .responseRange(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .responsePut?: try {
      guard case .responsePut(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .responseDeleteRange?: try {
      guard case .responseDeleteRange(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .responseTxn?: try {
      guard case .responseTxn(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_ResponseOp, rhs: Etcdserverpb_ResponseOp) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_Compare: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Compare"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "target"),
    3: .same(proto: "key"),
    4: .same(proto: "version"),
    5: .standard(proto: "create_revision"),
    6: .standard(proto: "mod_revision"),
    7: .same(proto: "value"),
    8: .same(proto: "lease"),
    64: .standard(proto: "range_end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.target) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.targetUnion != nil {try decoder.handleConflictingOneOf()}
          self.targetUnion = .version(v)
        }
      }()
      case 5: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.targetUnion != nil {try decoder.handleConflictingOneOf()}
          self.targetUnion = .createRevision(v)
        }
      }()
      case 6: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.targetUnion != nil {try decoder.handleConflictingOneOf()}
          self.targetUnion = .modRevision(v)
        }
      }()
      case 7: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.targetUnion != nil {try decoder.handleConflictingOneOf()}
          self.targetUnion = .value(v)
        }
      }()
      case 8: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.targetUnion != nil {try decoder.handleConflictingOneOf()}
          self.targetUnion = .lease(v)
        }
      }()
      case 64: try { try decoder.decodeSingularBytesField(value: &self.rangeEnd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .equal {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.target != .version {
      try visitor.visitSingularEnumField(value: self.target, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.targetUnion {
    case .version?: try {
      guard case .version(let v)? = self.targetUnion else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case .createRevision?: try {
      guard case .createRevision(let v)? = self.targetUnion else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }()
    case .modRevision?: try {
      guard case .modRevision(let v)? = self.targetUnion else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    }()
    case .value?: try {
      guard case .value(let v)? = self.targetUnion else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }()
    case .lease?: try {
      guard case .lease(let v)? = self.targetUnion else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    if !self.rangeEnd.isEmpty {
      try visitor.visitSingularBytesField(value: self.rangeEnd, fieldNumber: 64)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_Compare, rhs: Etcdserverpb_Compare) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.target != rhs.target {return false}
    if lhs.key != rhs.key {return false}
    if lhs.targetUnion != rhs.targetUnion {return false}
    if lhs.rangeEnd != rhs.rangeEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_Compare.CompareResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQUAL"),
    1: .same(proto: "GREATER"),
    2: .same(proto: "LESS"),
    3: .same(proto: "NOT_EQUAL"),
  ]
}

extension Etcdserverpb_Compare.CompareTarget: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION"),
    1: .same(proto: "CREATE"),
    2: .same(proto: "MOD"),
    3: .same(proto: "VALUE"),
    4: .same(proto: "LEASE"),
  ]
}

extension Etcdserverpb_TxnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxnRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "compare"),
    2: .same(proto: "success"),
    3: .same(proto: "failure"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.compare) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.success) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.failure) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.compare.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.compare, fieldNumber: 1)
    }
    if !self.success.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.success, fieldNumber: 2)
    }
    if !self.failure.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failure, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_TxnRequest, rhs: Etcdserverpb_TxnRequest) -> Bool {
    if lhs.compare != rhs.compare {return false}
    if lhs.success != rhs.success {return false}
    if lhs.failure != rhs.failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_TxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxnResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "succeeded"),
    3: .same(proto: "responses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.succeeded) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.succeeded != false {
      try visitor.visitSingularBoolField(value: self.succeeded, fieldNumber: 2)
    }
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_TxnResponse, rhs: Etcdserverpb_TxnResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.succeeded != rhs.succeeded {return false}
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_CompactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revision"),
    2: .same(proto: "physical"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.revision) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.physical) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.revision != 0 {
      try visitor.visitSingularInt64Field(value: self.revision, fieldNumber: 1)
    }
    if self.physical != false {
      try visitor.visitSingularBoolField(value: self.physical, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_CompactionRequest, rhs: Etcdserverpb_CompactionRequest) -> Bool {
    if lhs.revision != rhs.revision {return false}
    if lhs.physical != rhs.physical {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_CompactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompactionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_CompactionResponse, rhs: Etcdserverpb_CompactionResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_HashRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_HashRequest, rhs: Etcdserverpb_HashRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_HashKVRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashKVRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.revision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.revision != 0 {
      try visitor.visitSingularInt64Field(value: self.revision, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_HashKVRequest, rhs: Etcdserverpb_HashKVRequest) -> Bool {
    if lhs.revision != rhs.revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_HashKVResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashKVResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "hash"),
    3: .standard(proto: "compact_revision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.hash) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.compactRevision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.hash != 0 {
      try visitor.visitSingularUInt32Field(value: self.hash, fieldNumber: 2)
    }
    if self.compactRevision != 0 {
      try visitor.visitSingularInt64Field(value: self.compactRevision, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_HashKVResponse, rhs: Etcdserverpb_HashKVResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.compactRevision != rhs.compactRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_HashResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.hash != 0 {
      try visitor.visitSingularUInt32Field(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_HashResponse, rhs: Etcdserverpb_HashResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_SnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SnapshotRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_SnapshotRequest, rhs: Etcdserverpb_SnapshotRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_SnapshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SnapshotResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "remaining_bytes"),
    3: .same(proto: "blob"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.remainingBytes) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.remainingBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.remainingBytes, fieldNumber: 2)
    }
    if !self.blob.isEmpty {
      try visitor.visitSingularBytesField(value: self.blob, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_SnapshotResponse, rhs: Etcdserverpb_SnapshotResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.remainingBytes != rhs.remainingBytes {return false}
    if lhs.blob != rhs.blob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_WatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_request"),
    2: .standard(proto: "cancel_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Etcdserverpb_WatchCreateRequest?
        var hadOneofValue = false
        if let current = self.requestUnion {
          hadOneofValue = true
          if case .createRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestUnion = .createRequest(v)
        }
      }()
      case 2: try {
        var v: Etcdserverpb_WatchCancelRequest?
        var hadOneofValue = false
        if let current = self.requestUnion {
          hadOneofValue = true
          if case .cancelRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestUnion = .cancelRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requestUnion {
    case .createRequest?: try {
      guard case .createRequest(let v)? = self.requestUnion else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cancelRequest?: try {
      guard case .cancelRequest(let v)? = self.requestUnion else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_WatchRequest, rhs: Etcdserverpb_WatchRequest) -> Bool {
    if lhs.requestUnion != rhs.requestUnion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_WatchCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "range_end"),
    3: .standard(proto: "start_revision"),
    4: .standard(proto: "progress_notify"),
    5: .same(proto: "filters"),
    6: .standard(proto: "prev_kv"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rangeEnd) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startRevision) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.progressNotify) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.filters) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.prevKv) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.rangeEnd.isEmpty {
      try visitor.visitSingularBytesField(value: self.rangeEnd, fieldNumber: 2)
    }
    if self.startRevision != 0 {
      try visitor.visitSingularInt64Field(value: self.startRevision, fieldNumber: 3)
    }
    if self.progressNotify != false {
      try visitor.visitSingularBoolField(value: self.progressNotify, fieldNumber: 4)
    }
    if !self.filters.isEmpty {
      try visitor.visitPackedEnumField(value: self.filters, fieldNumber: 5)
    }
    if self.prevKv != false {
      try visitor.visitSingularBoolField(value: self.prevKv, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_WatchCreateRequest, rhs: Etcdserverpb_WatchCreateRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.rangeEnd != rhs.rangeEnd {return false}
    if lhs.startRevision != rhs.startRevision {return false}
    if lhs.progressNotify != rhs.progressNotify {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.prevKv != rhs.prevKv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_WatchCreateRequest.FilterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOPUT"),
    1: .same(proto: "NODELETE"),
  ]
}

extension Etcdserverpb_WatchCancelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchCancelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "watch_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.watchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.watchID != 0 {
      try visitor.visitSingularInt64Field(value: self.watchID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_WatchCancelRequest, rhs: Etcdserverpb_WatchCancelRequest) -> Bool {
    if lhs.watchID != rhs.watchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_WatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "watch_id"),
    3: .same(proto: "created"),
    4: .same(proto: "canceled"),
    5: .standard(proto: "compact_revision"),
    6: .standard(proto: "cancel_reason"),
    11: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.watchID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.created) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canceled) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.compactRevision) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.cancelReason) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.watchID != 0 {
      try visitor.visitSingularInt64Field(value: self.watchID, fieldNumber: 2)
    }
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 3)
    }
    if self.canceled != false {
      try visitor.visitSingularBoolField(value: self.canceled, fieldNumber: 4)
    }
    if self.compactRevision != 0 {
      try visitor.visitSingularInt64Field(value: self.compactRevision, fieldNumber: 5)
    }
    if !self.cancelReason.isEmpty {
      try visitor.visitSingularStringField(value: self.cancelReason, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_WatchResponse, rhs: Etcdserverpb_WatchResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.watchID != rhs.watchID {return false}
    if lhs.created != rhs.created {return false}
    if lhs.canceled != rhs.canceled {return false}
    if lhs.compactRevision != rhs.compactRevision {return false}
    if lhs.cancelReason != rhs.cancelReason {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseGrantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseGrantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TTL"),
    2: .same(proto: "ID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseGrantRequest, rhs: Etcdserverpb_LeaseGrantRequest) -> Bool {
    if lhs.ttl != rhs.ttl {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseGrantResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseGrantResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "ID"),
    3: .same(proto: "TTL"),
    4: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseGrantResponse, rhs: Etcdserverpb_LeaseGrantResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.id != rhs.id {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseRevokeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseRevokeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseRevokeRequest, rhs: Etcdserverpb_LeaseRevokeRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseRevokeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseRevokeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseRevokeResponse, rhs: Etcdserverpb_LeaseRevokeResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseKeepAliveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseKeepAliveRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseKeepAliveRequest, rhs: Etcdserverpb_LeaseKeepAliveRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseKeepAliveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseKeepAliveResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "ID"),
    3: .same(proto: "TTL"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseKeepAliveResponse, rhs: Etcdserverpb_LeaseKeepAliveResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.id != rhs.id {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseTimeToLiveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseTimeToLiveRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.keys != false {
      try visitor.visitSingularBoolField(value: self.keys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseTimeToLiveRequest, rhs: Etcdserverpb_LeaseTimeToLiveRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseTimeToLiveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseTimeToLiveResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "ID"),
    3: .same(proto: "TTL"),
    4: .same(proto: "grantedTTL"),
    5: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.grantedTtl) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    if self.grantedTtl != 0 {
      try visitor.visitSingularInt64Field(value: self.grantedTtl, fieldNumber: 4)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keys, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseTimeToLiveResponse, rhs: Etcdserverpb_LeaseTimeToLiveResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.id != rhs.id {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.grantedTtl != rhs.grantedTtl {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseLeasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseLeasesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseLeasesRequest, rhs: Etcdserverpb_LeaseLeasesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseStatus, rhs: Etcdserverpb_LeaseStatus) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_LeaseLeasesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaseLeasesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "leases"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.leases) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.leases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leases, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_LeaseLeasesResponse, rhs: Etcdserverpb_LeaseLeasesResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.leases != rhs.leases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "name"),
    3: .same(proto: "peerURLs"),
    4: .same(proto: "clientURLs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.peerUrls) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.clientUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.peerUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.peerUrls, fieldNumber: 3)
    }
    if !self.clientUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.clientUrls, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_Member, rhs: Etcdserverpb_Member) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.peerUrls != rhs.peerUrls {return false}
    if lhs.clientUrls != rhs.clientUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberAddRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberAddRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peerURLs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.peerUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peerUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.peerUrls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberAddRequest, rhs: Etcdserverpb_MemberAddRequest) -> Bool {
    if lhs.peerUrls != rhs.peerUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberAddResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberAddResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "member"),
    3: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberAddResponse, rhs: Etcdserverpb_MemberAddResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._member != rhs._member {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberRemoveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberRemoveRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberRemoveRequest, rhs: Etcdserverpb_MemberRemoveRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberRemoveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberRemoveResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberRemoveResponse, rhs: Etcdserverpb_MemberRemoveResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "peerURLs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.peerUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.peerUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.peerUrls, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberUpdateRequest, rhs: Etcdserverpb_MemberUpdateRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.peerUrls != rhs.peerUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberUpdateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberUpdateResponse, rhs: Etcdserverpb_MemberUpdateResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberListRequest, rhs: Etcdserverpb_MemberListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MemberListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MemberListResponse, rhs: Etcdserverpb_MemberListResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_DefragmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DefragmentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_DefragmentRequest, rhs: Etcdserverpb_DefragmentRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_DefragmentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DefragmentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_DefragmentResponse, rhs: Etcdserverpb_DefragmentResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MoveLeaderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveLeaderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MoveLeaderRequest, rhs: Etcdserverpb_MoveLeaderRequest) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_MoveLeaderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveLeaderResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_MoveLeaderResponse, rhs: Etcdserverpb_MoveLeaderResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AlarmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlarmRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "memberID"),
    3: .same(proto: "alarm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memberID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.alarm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .get {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.memberID != 0 {
      try visitor.visitSingularUInt64Field(value: self.memberID, fieldNumber: 2)
    }
    if self.alarm != .none {
      try visitor.visitSingularEnumField(value: self.alarm, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AlarmRequest, rhs: Etcdserverpb_AlarmRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.memberID != rhs.memberID {return false}
    if lhs.alarm != rhs.alarm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AlarmRequest.AlarmAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "ACTIVATE"),
    2: .same(proto: "DEACTIVATE"),
  ]
}

extension Etcdserverpb_AlarmMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlarmMember"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memberID"),
    2: .same(proto: "alarm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memberID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.alarm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memberID != 0 {
      try visitor.visitSingularUInt64Field(value: self.memberID, fieldNumber: 1)
    }
    if self.alarm != .none {
      try visitor.visitSingularEnumField(value: self.alarm, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AlarmMember, rhs: Etcdserverpb_AlarmMember) -> Bool {
    if lhs.memberID != rhs.memberID {return false}
    if lhs.alarm != rhs.alarm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AlarmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlarmResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "alarms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.alarms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.alarms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alarms, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AlarmResponse, rhs: Etcdserverpb_AlarmResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.alarms != rhs.alarms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_StatusRequest, rhs: Etcdserverpb_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "version"),
    3: .same(proto: "dbSize"),
    4: .same(proto: "leader"),
    5: .same(proto: "raftIndex"),
    6: .same(proto: "raftTerm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.dbSize) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.leader) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.raftIndex) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.raftTerm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.dbSize != 0 {
      try visitor.visitSingularInt64Field(value: self.dbSize, fieldNumber: 3)
    }
    if self.leader != 0 {
      try visitor.visitSingularUInt64Field(value: self.leader, fieldNumber: 4)
    }
    if self.raftIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.raftIndex, fieldNumber: 5)
    }
    if self.raftTerm != 0 {
      try visitor.visitSingularUInt64Field(value: self.raftTerm, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_StatusResponse, rhs: Etcdserverpb_StatusResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.version != rhs.version {return false}
    if lhs.dbSize != rhs.dbSize {return false}
    if lhs.leader != rhs.leader {return false}
    if lhs.raftIndex != rhs.raftIndex {return false}
    if lhs.raftTerm != rhs.raftTerm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthEnableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthEnableRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthEnableRequest, rhs: Etcdserverpb_AuthEnableRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthDisableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthDisableRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthDisableRequest, rhs: Etcdserverpb_AuthDisableRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthenticateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthenticateRequest, rhs: Etcdserverpb_AuthenticateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserAddRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserAddRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserAddRequest, rhs: Etcdserverpb_AuthUserAddRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserGetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserGetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserGetRequest, rhs: Etcdserverpb_AuthUserGetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserDeleteRequest, rhs: Etcdserverpb_AuthUserDeleteRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserChangePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserChangePasswordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserChangePasswordRequest, rhs: Etcdserverpb_AuthUserChangePasswordRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserGrantRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserGrantRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserGrantRoleRequest, rhs: Etcdserverpb_AuthUserGrantRoleRequest) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserRevokeRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserRevokeRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserRevokeRoleRequest, rhs: Etcdserverpb_AuthUserRevokeRoleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleAddRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleAddRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleAddRequest, rhs: Etcdserverpb_AuthRoleAddRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleGetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleGetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleGetRequest, rhs: Etcdserverpb_AuthRoleGetRequest) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserListRequest, rhs: Etcdserverpb_AuthUserListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleListRequest, rhs: Etcdserverpb_AuthRoleListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleDeleteRequest, rhs: Etcdserverpb_AuthRoleDeleteRequest) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleGrantPermissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleGrantPermissionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "perm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._perm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._perm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleGrantPermissionRequest, rhs: Etcdserverpb_AuthRoleGrantPermissionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._perm != rhs._perm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleRevokePermissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleRevokePermissionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "key"),
    3: .standard(proto: "range_end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rangeEnd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.rangeEnd.isEmpty {
      try visitor.visitSingularStringField(value: self.rangeEnd, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleRevokePermissionRequest, rhs: Etcdserverpb_AuthRoleRevokePermissionRequest) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.key != rhs.key {return false}
    if lhs.rangeEnd != rhs.rangeEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthEnableResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthEnableResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthEnableResponse, rhs: Etcdserverpb_AuthEnableResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthDisableResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthDisableResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthDisableResponse, rhs: Etcdserverpb_AuthDisableResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthenticateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthenticateResponse, rhs: Etcdserverpb_AuthenticateResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserAddResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserAddResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserAddResponse, rhs: Etcdserverpb_AuthUserAddResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserGetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserGetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "roles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserGetResponse, rhs: Etcdserverpb_AuthUserGetResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserDeleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserDeleteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserDeleteResponse, rhs: Etcdserverpb_AuthUserDeleteResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserChangePasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserChangePasswordResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserChangePasswordResponse, rhs: Etcdserverpb_AuthUserChangePasswordResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserGrantRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserGrantRoleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserGrantRoleResponse, rhs: Etcdserverpb_AuthUserGrantRoleResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserRevokeRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserRevokeRoleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserRevokeRoleResponse, rhs: Etcdserverpb_AuthUserRevokeRoleResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleAddResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleAddResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleAddResponse, rhs: Etcdserverpb_AuthRoleAddResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleGetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleGetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "perm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.perm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.perm.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.perm, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleGetResponse, rhs: Etcdserverpb_AuthRoleGetResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.perm != rhs.perm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "roles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleListResponse, rhs: Etcdserverpb_AuthRoleListResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthUserListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthUserListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedStringField(value: self.users, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthUserListResponse, rhs: Etcdserverpb_AuthUserListResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleDeleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleDeleteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleDeleteResponse, rhs: Etcdserverpb_AuthRoleDeleteResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleGrantPermissionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleGrantPermissionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleGrantPermissionResponse, rhs: Etcdserverpb_AuthRoleGrantPermissionResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etcdserverpb_AuthRoleRevokePermissionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRoleRevokePermissionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etcdserverpb_AuthRoleRevokePermissionResponse, rhs: Etcdserverpb_AuthRoleRevokePermissionResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
